package rbc

import (
	"bytes"
	"fmt"
	"github.com/klauspost/reedsolomon"
)

/*
The erasure coding package of `github.com/klauspost/reedsolomon` can only deal with the situation that some shards are missing
it cannot deal with the situation that the content in a shard is modified, even if there are more than k correct shards
*/

// encode the data via erasure coding
// @k: the number of required shards to reconstruct the original data
// @p: number of parity shards
func encode(data []byte, k, p int) ([][]byte, error) {
	enc, err := reedsolomon.New(k, p)
	if err != nil {
		return nil, err
	}

	// Split the data into equally sized shards.
	shards, err := enc.Split(data)
	if err != nil {
		return nil, err
	}

	// Encode parity
	err = enc.Encode(shards)
	if err != nil {
		return nil, err
	}

	return shards, nil
}

// decode the shards generated by erasure coding into the original data
// @k: the number of required shards to reconstruct the original data
// @p: number of parity shards
// @dataLen: length of the original data, which is necessary
func decode(shards [][]byte, k, p int, dataLen int) ([]byte, error) {
	enc, err := reedsolomon.New(k, p)
	if err != nil {
		return nil, err
	}

	// Verify the shards, reconstruct it if needed
	if ok, err := enc.Verify(shards); !ok {
		err = enc.Reconstruct(shards)
		if err != nil {
			fmt.Println("Reconstruct failed -", err)
			return nil, err
		}
		ok, err = enc.Verify(shards)
		if !ok || err != nil {
			fmt.Println("Verification failed after reconstruction, data likely corrupted.")
			return nil, err
		}
	}

	var buffer bytes.Buffer
	err = enc.Join(&buffer, shards, dataLen)
	if err != nil {
		return nil, err
	}

	return buffer.Bytes(), nil
}
